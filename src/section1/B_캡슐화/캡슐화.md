## 캡슐화
__정의__ : 데이터 + 관련 기능 묶기  
객체가 기능을 어떻게 구현했는지 외부에 감추는 것  
  
* 과거에는 정보 은닉을 캡슐화와 분리해서 정의했지만 최근에는 정보 은닉을 포함한다.

---

### 캡슐화를 왜 할까?
외부 영향 없이 객체 내부 구현 변경 가능

---

### 캡슐화를 하지 않으면...
요구사항의 변화(수정 또는 추가 등)가 발생해서  
데이터 구조/사용에 변화를 발생시켰을 경우  
데이터를 사용하는 __여러 코드의 수정이 발생__ 한다.
* 잔득 ctrl + c / ctrl + v를 해야한다.
* 소스 변경이 연쇄적으로 매우 많이 발생한다.

### 캡슐화를 했을 때...
요구사항이 변화하게 되면 [캡슐화를했을때.java](%EC%BA%A1%EC%8A%90%ED%99%94%EB%A5%BC%ED%96%88%EC%9D%84%EB%95%8C.java) 해당 클래스를 변경하는 것이 아니라  
[Account.java](%EC%98%88%EC%A0%9C%ED%81%B4%EB%9E%98%EC%8A%A4%2FAccount.java) 클래스의 기능만 변경하면 끝난다.  
(__연쇄적인 변경이 없다.__)

---

### 캡슐화를 위한 규칙
1. Tell, Don't Ask : 데이터를 달라고 하지 말고 기능을 __해달라고__ 하기
```java
if(acc.getMembership() == REGULAR) {}
```
위 처럼 데이터를 받아서 판단하는 것 보다
```java
if(acc.hasRegularPermission()) {}
```
위 코드처럼 기능을 수행 __해달라고__ 하는 것이 좋다.

2. Demeter's Law
* 메서드에서 생성한 객체의 메서드만 호출
* 파라미터로 받은 객체의 메서드만 호출
* 필드로 참조하는 객체의 메서드만 호출
```java
acc.getExpDate().isAfter(now());

Date date = acc.getExpDate();
date.isAfter(now());
```
위 코드처럼 또 다시 데이터를 가져와서 판단하기보다
```java
acc.isExpired();
acc.isValid(now());
```
위 코드처럼 기능을 호출하는 것이 낫다.

---

### 결론
캡슐화를 통해서 다시 말하지만 __기능의 구현을 외부에 감추는 것__ 이 매우 중요하다.  
캡슐화를 하게 되면 기능을 사용하는 코드 또는 코드들에 영향을 주지 않는다. 즉, 불필요한 다발성 코드 수정 작업을 줄일 수 있게 되고  
개발 비용(=시간)을 크게 절감할 수 있다.
  
### 생각...
늘상 하던 작업인 __기능 공통화__ 와 비슷한 것 같다.  
동일한 코드가 ctrl c,v로 남발되는 것이 보기 안 좋고  
기능 하나가 변경되면 프로젝트 내의 모든 java 파일을 뒤져서  
하나하나 다 바꿔줘야하는 작업에 환멸을 느껴서 기능을 하나로 묶는 공통 작업을 자주 했었는데,  
다만 이렇게 되면 결합도가 높아져서 추후에 기능을 분리할 때 어렵긴한데...  
개발자가 눈치껏 잘 활용하는게 중요한 것 같다...