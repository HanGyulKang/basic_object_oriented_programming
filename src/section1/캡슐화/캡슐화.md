## 캡슐화
__정의__ : 데이터 + 관련 기능 묶기  
객체가 기능을 어떻게 구현했는지 외부에 감추는 것  
  
* 과거에는 정보 은닉을 캡슐화와 분리해서 정의했지만 최근에는 정보 은닉을 포함한다.

---

### 캡슐화를 왜 할까?
외부 영향 없이 객체 내부 구현 변경 가능

---

### 캡슐화를 하지 않으면...
요구사항의 변화(수정 또는 추가 등)가 발생해서  
데이터 구조/사용에 변화를 발생시켰을 경우  
데이터를 사용하는 __여러 코드의 수정이 발생__ 한다.
* 잔득 ctrl + c / ctrl + v를 해야한다.
* 소스 변경이 연쇄적으로 매우 많이 발생한다.

### 캡슐화를 했을 때...
요구사항이 변화하게 되면 [캡슐화를했을때.java](%EC%BA%A1%EC%8A%90%ED%99%94%EB%A5%BC%ED%96%88%EC%9D%84%EB%95%8C.java) 해당 클래스를 변경하는 것이 아니라  
[Account.java](%EC%98%88%EC%A0%9C%ED%81%B4%EB%9E%98%EC%8A%A4%2FAccount.java) 클래스의 기능만 변경하면 끝난다.  
(__연쇄적인 변경이 없다.__)

---

### 캡슐화를 위한 규칙
1. Tell, Don't Ask : 데이터를 달라고 하지 말고 기능을 __해달라고__ 하기
```java
if(acc.getMembership() == REGULAR) {}
```
위 처럼 데이터를 받아서 판단하는 것 보다
```java
if(acc.hasRegularPermission()) {}
```
위 코드처럼 기능을 수행 __해달라고__ 하는 것이 좋다.

2. Demeter's Law
* 메서드에서 생성한 객체의 메서드만 호출
* 파라미터로 받은 객체의 메서드만 호출
* 필드로 참조하는 객체의 메서드만 호출
```java
acc.getExpDate().isAfter(now());

Date date = acc.getExpDate();
date.isAfter(now());
```
위 코드처럼 또 다시 데이터를 가져와서 판단하기보다
```java
acc.isExpired();
acc.isValid(now());
```
위 코드처럼 기능을 호출하는 것이 낫다.

---

### 결론
캡슐화를 통해서 다시 말하지만 __기능의 구현을 외부에 감추는 것__ 이 매우 중요하다.  
캡슐화를 하게 되면 기능을 사용하는 코드 또는 코드들에 영향을 주지 않는다. 즉, 불필요한 다발성 코드 수정 작업을 줄일 수 있게 되고  
개발 비용(=시간)을 크게 절감할 수 있다.